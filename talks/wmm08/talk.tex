% $Header: /project/cl/Root/CVS/talks/iowa08/talk.tex,v 1.3 2008/01/31 14:11:37 stump Exp $

\documentclass[11pt]{beamer}

\usepackage{tikz}
\usepackage{pgflibraryarrows}
\usepackage{pgflibraryshapes}
\usepackage{pgfbaseimage}
\usepackage{proof}
\usepackage{url}

\newcommand{\Eq}[0]{\texttt{=}}
\newcommand{\Neq}[0]{\texttt{!=}}
\newcommand{\Qeq}[0]{\stackrel{?}{=}}
\newcommand{\bang}[0]{\texttt{!}}
\newcommand{\quant}[0]{\textit{Quant}}

\newcommand{\To}[0]{\Rightarrow}
\newcommand{\rn}[1]{\textsc{#1}}
\newcommand{\interp}[1]{[ \negthinspace [ #1 ] \negthinspace ]}

\newcommand{\seq}[3]{#1 \vdash #2 : #3}
%\newcommand{\aseq}[3]{ #2 : #3}
\newcommand{\aseq}[3]{ #1 \vdash #3}
%\newcommand{\aaseq}[3]{ #3}
\newcommand{\aaseq}[3]{ #1 \vdash #3}
\newcommand{\abseq}[3]{ #1 \vdash #3}
\mode<presentation>
{
  %\usetheme{Warsaw}
  % or ...

\usetheme{IowaCity}
%\usetheme{Edinburgh}

%  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}


\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\title[Verified Tools in OpTT]
{Building Verified Language Tools in\\ Operational Type Theory}

\author{Aaron~Stump}

\institute[Computational Logic Center]
{
  Computational Logic Center\\
  Computer Science Department \\
  The University of Iowa\\
\ \\ 
\ \\ Thanks to Morgan Deters and Todd Schiller.
\ \\
\ \\
Funding from NSF CAREER. 
}

\pgfdeclareimage[height=2cm]{laundry}{laundry}
\pgfdeclareimage[height=3cm]{car}{repaired-car}

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
%\AtBeginSubsection[]
%{
%  \begin{frame}<beamer>
%    \frametitle{Outline}
%    \tableofcontents[currentsection,currentsubsection]
%  \end{frame}
%}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}

\begin{document}

\date{\ }

\begin{frame}[plain]
  \titlepage
\end{frame}

\date{WMM '08}

\begin{frame}
  \frametitle{From Meta-Theory to Tools}

\begin{itemize}
\item Mechanized meta-theory great.


\begin{center}
\pgfuseimage{laundry}
\end{center}


\item Verified language tools also great!


\begin{center}
\pgfuseimage{car}
\end{center}


\item The combination definitely the greatest.

\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Meta-theory and Tools for LF}
\begin{itemize}
\item Paper meta-theory for LF \textcolor{blue}{[Harper+05],[Watkins+02]}.
\item Machine-checked meta-theory for LF \textcolor{blue}{[Urban+08]}.
\item Unverified tools for LF: \textsc{Twelf}, \textsc{flit}, \textsc{sc}, \textsc{lfsc}.
\item Verified tool (this talk): \textsc{Golfsock}.
\begin{itemize}
\item Verify that optimized LF checker builds type-correct LF.
\item Uses a declarative presentation of LF.
\item That presentation could be simpler.
\item More meta-theory would be needed.
\item Balance simplicity of specification, ease of verification.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Incremental Checking}
\begin{itemize}
\item Basic idea: interleave parsing and checking \textcolor{blue}{[Stump08]}.
\item Combine with bidirectional type checking.
\begin{itemize}
\item Synthesizing: $\Gamma \vdash t \Rightarrow T$.
\item Checking: $\Gamma \vdash t \Leftarrow T$.
\end{itemize}
\item ASTs built for subterms iff they will appear in the type $T$.

E.g., 

\begin{verbatim}
(refl x+y) => x+y == x+y
\end{verbatim}

\begin{itemize}
\item AST must be built for \texttt{x+y}.
\item But not \texttt{(refl x+y)}.
\end{itemize}

\item C++ implementation: small footprint, fastest checker I know.

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Need for Correctness}

\begin{itemize}
\item LF with Side Conditions (LFSC) proposed for SMT.
\begin{itemize}
\item Satisfiability Modulo Theories.
\item SMT solvers check large formulas, produce big proofs.
\item Must check proofs efficiently.
\item LFSC provides flexible intermediate proof language.
\end{itemize}
\item Problems with C++ (proof checker):
\begin{itemize}
\item Lack of memory safety => many days with \textsc{valgrind}.
\item Optimizations reduce trustworthiness.
\end{itemize}
\item As features are added to checker, trust diminishes.
\item Additional assurance is required.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textsc{Golfsock}: Towards A Verified LF Checker}
\begin{itemize}
\item Goal: implement verified LFSC checker.
\item \textsc{Golfsock}: incremental LF checker in \textsc{Guru}.
\begin{itemize}
\item \textsc{Guru} is a verified programming language.
\item Combines a dependently type PL, logical theory (OpTT).
\item Supports mutable state, non-termination, input/output.
\item Type/proof checker, compiler to efficient C code.
\item Beating native code \textsc{OCaml} on small testcases.
\end{itemize}
\item Status:
\begin{itemize}
\item \textsc{Golfsock} implemented.
\item Running reasonably fast: 40\% slower than C++ version.
\item Specification: ASTs we build are type correct LF.
\item Expressed with dependent types, declarative LF.
\item A number of lemmas still to prove.
\item 4300 lines code, proof.
\item 13000 lines standard library (e.g., tries).
\end{itemize}
\end{itemize}
\end{frame}



\end{document}

