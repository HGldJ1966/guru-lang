#summary a list of proof rules and their usage

= Summary of Proof Syntax =

|| *join* _term_ _term_ || *join* proves the equality of the two terms by evaluating them. ||
|| *clash* _term_ _term_ || *clash* proves the disequality of the two distinct constants of the same type. ||
|| *trans* _proof1_ _proof2_ || When _proof1_ proves A = B and _proof2_ proves B = C, then *trans* proves A = C. Or if one of them is disequality, it proves A != C. ||
|| *symm* _proof_ || If _proof_ proves A = C, then *symm* proves C = A. ||

|| *foralli* { _param_ }+ *.* _proof_ || ||
|| *`[`* _proof_ { _argument_ }`*` *`]`* || _proof_ should be a universally quantified formula. ||

|| *case* _term_ *with* _pattern_ *=>* _proof_ { | _pattern_ *=>* _proof_ }`*` *end* || _term_ should be a terminating term ||
|| *case* _term_ *by* _var1_ _var2_ *with* _pattern_ *=>* _proof_ { | _pattern_ *=>* _proof_ }`*` *end* || _var1_ is instantiated with the proof of the equality of _term_ and each _pattern_. And _var2_ is instantiated with the proof of the equality of *types* of them. ||
|| *induction* { _param_ }+ *return* _formula_ *with* _pattern_ *=>* _proof_ { | _pattern_ *=>* _proof_ }`*` *end* || *induction* introduces Foralls for each parameter. Even if multiple parameters are given, it does actually induction on the last one. ||
|| *contra* _proof_ _formula_ || _proof_ should prove a contradiction, and *contra* trivially proves _formula_. ||

|| *existsi* _value_ _formula`*`_ _proof_ || _proof_ should prove _formula`*`_`[`_value_`]` ||
|| *existse* _proof1_ _proof2_ || _proof1_ should prove a formula like `Exists(x:nat).F`, and _proof2_ should prove a formula like `Forall(x:nat)(u:F).F2`. ||

|| *hypjoin* _term_ _term_ *by* { _proof_ }`*` *end* || more automated version of join, combined with trans and symm ||



= More Information about the Rules =

== clash ==

|| *clash* _term_ _term_ || *clash* proves the disequality of the two distinct constants of the same type. ||

*clash* proves the disequality of two different values of the same type, which cannot be proved to be equal. For example, `tt != ff`, `(S Z) != (S (S Z))`. With inductive data types, you cannot construct the same value in multiple ways. That means if two constants are syntactically different, they are unequal by definition.

== contra ==

|| *contra* _proof_ _formula_ || the _proof_ should prove a contradiction, and *contra* trivially proves _formula_. ||

A contradiction here is an disequality of the same term. *contra* rules is usually used in *case* proofs. A proof of disequality often involves a *clash* proof.