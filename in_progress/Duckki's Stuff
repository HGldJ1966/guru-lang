Hi,

I've heard some of us are working on list subset function. Actually,
I've implemented similar function and proved some lemmas about it.
But, because my function is specialized for a certain type, we could
work together on a general version.

Here's my function:

Define lit := <pair bool word>.
Define clause := <list lit>.

% c1 subsumes c2
Define cl_subsume :=
  fun cl_subsume(c1:clause)(c2:clause) : bool.
    match c1 with
      nil _ => tt  % trivially true
    | cons _ l c1' =>
        (and (member lit l c2 eq_lit)
             (cl_subsume c1' c2))
    end.

In the function above, c2 includes c1. Because clauses are interpreted
disjuctively, the shorter list subsumes the longer. The function could
be implemented non-recursively using list_forall function, which would
be better.

Here are some of the lemmas that I've proved. You might be intested in
proving them. Because the function involves "member" function, I
needed member related lemmas as well. By the way, It may get more
interested when "removeAll" function is involved. But, I haven't
tested that function, yet. (I've been using my own "erase" function,
though, I'm planning to switch.)

Define member_or_append :
  Forall(A:type)
        (eq:Fun(a b:A).bool)
        (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
        (x:A)
        (l1:<list A>)(l2:<list A>).
    { (or (member x l1 eq) (member x l2 eq))
      = (member x (append l1 l2) eq) }
  :=
  foralli(A:type)
         (eq:Fun(a b:A).bool)
         (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
         (x:A).
  induction(l1:<list A>)
    return Forall(l2:<list A>).
             { (or (member x l1 eq) (member x l2 eq))
               = (member x (append l1 l2) eq) }
  with
    nil _ =>
      foralli(l2:<list A>).
      existse [member_total A x l2 eq eq_tot]
        foralli(z2:bool)(z2_pf:{(member x l2 eq) = z2}).
      hypjoin (or (member x l1 eq) (member x l2 eq))
              (member x (append l1 l2) eq)
        by l1_eq z2_pf [append_nil A l1] [or_comm ff z2] [or_def2ff
z2] end
  | cons _ a l1' =>
      foralli(l2:<list A>).
      existse [eq_tot x a]
        foralli(za:bool)(za_pf:{(eq x a) = za}).
      existse [member_total A x l1' eq eq_tot]
        foralli(z1':bool)(z1'_pf:{(member x l1' eq) = z1'}).
      existse [member_total A x l2 eq eq_tot]
        foralli(z2:bool)(z2_pf:{(member x l2 eq) = z2}).
      trans hypjoin (or (member x l1 eq) (member x l2 eq))
                    (or (or za z1') z2) by l1_eq za_pf z1'_pf z2_pf
end
      trans [or_assoc za z1' z2]
      trans hypjoin (or za (or z1' z2))
                    (or (eq x a) (or (member x l1' eq) (member x l2
eq)))
              by l1_eq za_pf z1'_pf z2_pf end
      trans cong (or (eq x a) *) [l1_IH l1' l2]
            hypjoin (or (eq x a) (member x (append l1' l2) eq))
                    (member x (append l1 l2) eq)
              by l1_eq end

  end.

Define member_tt_append :
  Forall(A:type)
        (eq:Fun(a b:A).bool)
        (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
        (a:A)(l1:<list A>)(l2:<list A>)
        (u1: {(member a l1 eq) = tt}).
        { (member a (append l1 l2) eq) = tt }
  :=
  foralli(A:type)
         (eq:Fun(a b:A).bool)
         (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
         (a:A)(l1:<list A>)(l2:<list A>)
         (u1: {(member a l1 eq) = tt}).
  trans symm [member_or_append A eq eq_tot a l1 l2]
  trans cong (or * (member a l2 eq)) u1
  trans [or_comm tt (member A a l2 eq)]
        [or_tt (member A a l2 eq)]
        .

Define member_tt_cons :
  Forall(A:type)
        (eq:Fun(a b:A).bool)
        (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
        (a:A)(l:<list A>)(b:A)
        (u: {(member a l eq) = tt}).
        { (member a (cons b l) eq) = tt }
  :=
  foralli(A:type)
         (eq:Fun(a b:A).bool)
         (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
         (a:A)(l:<list A>)(b:A)
         (u: {(member a l eq) = tt}).
  existse [eq_tot a b]
    foralli(z:bool)(z_eq:{ (eq a b) = z }).
  trans hypjoin (member a (cons b l) eq)
                (or z tt)
          by u z_eq end
        [or_tt z]
        .

Define member_tt_append_front :
  Forall(A:type)
        (eq:Fun(a b:A).bool)
        (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
        (a:A)(l1:<list A>)(l2:<list A>)
        (u1: {(member a l1 eq) = tt}).
        { (member a (append l2 l1) eq) = tt }
  :=
  foralli(A:type)
         (eq:Fun(a b:A).bool)
         (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
         (a:A)(l1:<list A>)(l2:<list A>)
         (u1: {(member a l1 eq) = tt}).
  trans symm [member_or_append A eq eq_tot a l2 l1]
        % (member a l2++l1) = (or (member a l2) (member a l1))
  trans cong (or (member a l2 eq) *) u1
        % = (or (member a l2) tt)
        [or_tt (member A a l2 eq)]
        .

Define member_cons_ff :
  Forall(A:type)
        (eq:Fun(a b:A).bool)
        (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
        (a:A)(l:<list A>)(b:A)
        (u: {(member a (cons b l) eq) = ff}).
    { (member a l eq) = ff }
  :=
  foralli(A:type)
         (eq:Fun(a b:A).bool)
         (eq_tot:Forall(a b:A).Exists(z:bool).{ (eq a b) = z })
         (a:A)(l:<list A>)(b:A)
         (u: {(member a (cons b l) eq) = ff}).
  existse [eq_tot a b]
    foralli(z1:bool)(z1_pf:{ (eq a b) = z1 }).
  existse [member_total A a l eq eq_tot]
    foralli(z2:bool)(z2_pf:{ (member a l eq) = z2 }).
  abbrev p1 =
    hypjoin (or z1 z2) ff
      by u z1_pf z2_pf end
  in
  trans [or_ffr z1 z2 p1]
        symm z2_pf
  .

Define cl_subsume_total :=
  induction(c1:clause) return
    Forall(c2:clause).Exists(z:bool).{(cl_subsume c1 c2) = z}
  with
    nil _ =>
      foralli(c2:clause).
      existsi tt { (cl_subsume c1 c2) = * }
        hypjoin (cl_subsume c1 c2) tt by c1_eq end
  | cons _ l c1' =>
      foralli(c2:clause).
      existse [member_total lit l c2 eq_lit eq_lit_total]
        foralli(z1:bool)(z1_eq:{ (member lit l c2 eq_lit) = z1 }).
      existse [c1_IH c1' c2]
        foralli(z2:bool)(z2_eq:{ (cl_subsume c1' c2) = z2 }).
      existsi (and z1 z2) { (cl_subsume c1 c2) = * }
        hypjoin (cl_subsume c1 c2) (and z1 z2) by c1_eq z1_eq z2_eq
end
  end.

Define cl_subsume_cons_tt_member :
  Forall(l:lit)(c1 c2:clause)(u:{ (cl_subsume (cons l c1) c2) = tt }).
    { (member l c2 eq_lit) = tt }
  :=
  foralli(l:lit)(c1 c2:clause)(u:{ (cl_subsume (cons l c1) c2) =
tt }).
  existse [member_total lit l c2 eq_lit eq_lit_total]
    foralli(z1:bool)(z1_eq:{ (member lit l c2 eq_lit) = z1 }).
  existse [cl_subsume_total c1 c2]
    foralli(z2:bool)(z2_eq:{ (cl_subsume c1 c2) = z2 }).
  abbrev p1 =
    trans symm u
          hypjoin (cl_subsume (cons l c1) c2)
                  (and z1 z2)
            by z1_eq z2_eq end
  in
  trans z1_eq
        [and_eq_tt1 z1 z2 symm p1]
  .

Define cl_subsume_cons_tt_subsume :
  Forall(l:lit)(c1 c2:clause)(u:{ (cl_subsume (cons l c1) c2) = tt }).
    { (cl_subsume c1 c2) = tt }
  :=
  foralli(l:lit)(c1 c2:clause)(u:{ (cl_subsume (cons l c1) c2) =
tt }).
  existse [member_total lit l c2 eq_lit eq_lit_total]
    foralli(z1:bool)(z1_eq:{ (member lit l c2 eq_lit) = z1 }).
  existse [cl_subsume_total c1 c2]
    foralli(z2:bool)(z2_eq:{ (cl_subsume c1 c2) = z2 }).
  abbrev p1 =
    trans symm u
          hypjoin (cl_subsume (cons l c1) c2)
                  (and z1 z2)
            by z1_eq z2_eq end
  in
  trans z2_eq
        [and_eq_tt2 z1 z2 symm p1]
  .

Define cl_subsume_tt_append :
  Forall(c1 c2 c3:clause)(u:{ (cl_subsume c1 c2) = tt }).
    { (cl_subsume c1 (append c2 c3)) = tt }
  :=
  induction(c1:clause) return
    Forall(c2 c3:clause)(u:{ (cl_subsume c1 c2) = tt }).
      { (cl_subsume c1 (append c2 c3)) = tt }
  with
    nil _ =>
      foralli(c2 c3:clause)(u:{ (cl_subsume c1 c2) = tt }).
      hypjoin (cl_subsume c1 (append c2 c3)) tt by c1_eq end
  | cons _ l c1' =>
      foralli(c2 c3:clause)(u:{ (cl_subsume c1 c2) = tt }).
      abbrev p1 = trans cong (cl_subsume * c2) symm c1_eq
                        u
      in
      abbrev p2 = [cl_subsume_cons_tt_member l c1' c2 p1] in
      abbrev p3 = [cl_subsume_cons_tt_subsume l c1' c2 p1] in
      trans hypjoin (cl_subsume c1 (append c2 c3))
                    (and (member l (append c2 c3) eq_lit)
                         (cl_subsume c1' (append c2 c3)))
              by c1_eq end
            hypjoin (and (member l (append c2 c3) eq_lit)
                         (cl_subsume c1' (append c2 c3)))
                    tt
              by [member_tt_append lit eq_lit eq_lit_total l c2 c3 p2]
                 [c1_IH c1' c2 c3 p3]
              end
  end.

Define cl_subsume_tt_cons :
  Forall(c1 c2:clause)(l:lit)(u:{ (cl_subsume c1 c2) = tt }).
    { (cl_subsume c1 (cons l c2)) = tt }
  :=
  induction(c1:clause) return
    Forall(c2:clause)(l:lit)(u:{ (cl_subsume c1 c2) = tt }).
      { (cl_subsume c1 (cons l c2)) = tt }
  with
    nil _ =>
      foralli(c2:clause)(l:lit)(u:{ (cl_subsume c1 c2) = tt }).
      hypjoin (cl_subsume c1 (cons l c2)) tt by c1_eq end
  | cons _ l' c1' =>
      foralli(c2:clause)(l:lit)(u:{ (cl_subsume c1 c2) = tt }).
      abbrev p1 = trans cong (cl_subsume * c2) symm c1_eq
                        u
      in
      abbrev p2 = [cl_subsume_cons_tt_member l' c1' c2 p1] in
      abbrev p3 = [cl_subsume_cons_tt_subsume l' c1' c2 p1] in
      trans hypjoin (cl_subsume c1 (cons l c2))
                    (and (member l' (cons l c2) eq_lit)
                         (cl_subsume c1' (cons l c2)))
              by c1_eq end
            hypjoin (and (member l' (cons l c2) eq_lit)
                         (cl_subsume c1' (cons l c2)))
                    tt
              by [member_tt_cons lit eq_lit 
