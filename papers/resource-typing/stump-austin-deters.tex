\documentclass[9pt,natbib]{sigplanconf}

%\usepackage{latex8}
%\usepackage{times}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{url}

% \usepackage{natbib}
%  \bibpunct();A{},
%  \let\cite=\citep

\pdfpagewidth=8.5in
\pdfpageheight=11in

\newcommand{\lam}[2]{\lambda #1 . #2}
\newcommand{\lams}[2]{\lambda^* #1 . #2}
\newcommand{\alet}[3]{\textit{let}\ #1\ :=\ #2\ \textit{in}\ #3}
\newcommand{\Thet}[1]{\lam{V}{\lam{L}{\lam{A}{\lam{O}{\lam{C}{\lam{S}{\lam{D}{#1}}}}}}}}
\newcommand{\ope}[0]{\textit{open}}
\newcommand{\swap}[0]{\textit{swap}}
\newcommand{\vcomp}[0]{\textit{vcomp}}
\newcommand{\nlambda}[0]{\bar{\lambda}}
\newcommand{\nlam}[2]{\nlambda #1 . #2}
\newcommand{\rulename}[1]{\text{\textup{\textsf{#1}}}}
\newcommand\bs{\char '134 }  % A backslash character for \tt font
\newcommand{\seq}[3]{#1 \vdash #2 : #3}
\newcommand{\eval}[0]{\Downarrow}
\newcommand{\evalj}[2]{#1\, \eval\, #2}
\newcommand{\starstar}[0]{*\negthinspace*}
\newcommand{\nat}[0]{\mathbb{N}}
\newcommand{\optt}{\textsc{OpTT}}

\newcommand{\rase}[1]{\ulcorner #1 \urcorner}
\newcommand{\lowr}[1]{\llcorner #1 \lrcorner}

\newcommand{\Eq}[0]{\texttt{=}}
\newcommand{\Neq}[0]{\texttt{!=}}
\newcommand{\Qeq}[0]{\stackrel{?}{=}}
\newcommand{\bang}[0]{\texttt{!}}
\newcommand{\quant}[0]{\textit{Quant}}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\newcommand{\To}{\Rightarrow}
\newcommand{\gtrans}[2]{#1 \cdot #2}
\newcommand{\gtransa}[2]{#1 \cdot_1 #2}
\newcommand{\gtransb}[2]{#1 \cdot_2 #2}
\newcommand{\gsymm}[1]{#1^{-1}}
\newcommand{\gcong}[1]{f(#1)}
\newcommand{\ginj}[1]{f^{-1}(#1)}
\newcommand{\guru}[0]{\textsc{Guru}}

\begin{document}

\conferenceinfo{PLPV'10,} {January 19, 2010, Madrid, Spain.}
\CopyrightYear{2010}
\copyrightdata{\ } 

\titlebanner{\ }        % These are ignored unless
\preprintfooter{\ }   % 'preprint' option specified.


%\newenvironment{proof}
%               {\hspace{-1\parindent}\textbf{Proof:}}
%               {\hfill $\square$\vspace{1\baselineskip}}

\title{Resource Typing in Guru}

\authorinfo{Aaron Stump}
{CS Dept.\\ The University of Iowa, USA}
{astump@acm.org}

\authorinfo{Evan Austin}
{CS Dept.\\ The University of Kansas, USA}
{ecaustin@ittc.ku.edu}
%\date{}

\authorinfo{Morgan Deters}
{CS Dept.\\ New York University, USA}
{mdeters@cs.nyu.edu}
%\date{}

\maketitle

%\thispagestyle{empty}

\begin{abstract}
This paper presents a resource typing framework for the Guru
verified-programming language, in which abstractions for various kinds
of program resources can be defined.  Implemented examples include
reference-counted data, mutable arrays, and heap-allocated mutable
aliased data.  Each kind of resource is optionally described by a
functional model, enabling external reasoning about programs that use
resources.  During compilation, this functional model is replaced by
its actual imperative implementation.  This approach enables
efficient, type-safe programming with mutable and aliased data
structures, with explicit deallocation (not garbage collection).  We
demonstrate the approach with two examples: binary search in a mutable
array where we statically verify array bounds are respected; and
(mutable) FIFO queues, where we statically verify that the ``in''-end
of the queue has no next-pointer.
\end{abstract}

\category{D.3.2}{Programming Languages}{Applicative (functional) languages}
\category{F.3.1}{Logics and Meanings of Programs}{Mechanical verification}
\category{F.4.1}{Mathematical Logic}{Mechanical theorem proving}

\terms
Languages, Verification

\keywords
Dependently Typed Programming, Resource Types, Aliasing, Language-Based Verification

\section{Introduction}

Dependent types are of significant current interest for practical
verified programming, as a substantial number of recent works attest
(e.g.,~\cite{oury+08,norell07,pasalic+07,sheard06,nanevski+05,licata+05,chenxi05}).
Dependent types hold out the promise of incrementally extending the
verification power of traditional type systems.  With traditional
verification methods, there often at least appears to be a significant
shift in thinking required for programmers to apply the method.  For
example, with traditional approaches based on Hoare Logic, one in
general needs to annotate loops with loop invariants written in a
separate logical language, not likely to be familiar to mainstream
programmers.  In contrast, with dependent types, programmers can
incrementally enrich types with which they are well familiar.  For
example, it is a relatively small conceptual leap to go from a type
like $\langle \texttt{list}\ A\rangle$ (for homogeneous lists) to a
type like $\langle \texttt{list}\ A\ n\rangle$ (for homogeneous lists
of length $n$).  Of course, the richer the properties expressed by the
types, the more verification burden we might expect.  But still, with
dependent types, there seems a better change of incrementally
exploring the continuum of correctness, starting with current
programming practice, than with traditional verification methods.

But current dependent type systems are largely confined to functional
programming languages.  Despite the great intellectual depth of the
literature on functional programming, and enthusiastic user
communities, adoption of functional programming is miniscule compared
to industrial languages like C/C++ or Java.  There are, no doubt, many
non-techical reasons for this, such as maturity of standard libraries
(it is very difficult to compete, for example, with the massive
standard library for Java).  But there is at least one technical issue
which has always plagued functional programming languages, and others
based on automatic memory management: efficiency.  Again, despite
tremendous invention in the field, garbage collection remains costly,
as several recent studies report~\cite{Xian2008,hertz+05}.

This paper shows how to combine the expressive power of dependent
types with linear types to define imperative abstractions for
different kinds of resources, without the need for garbage collection.
This is carried out in the context of the Guru verified-programming
language, a dependently typed pure functional programming language.
Resources are created and consumed explicitly.  The type system rules
out memory errors such as accessing deallocated or uninitialized
memory by ensuring that each resource is consumed exactly once.  The
definition of a resource is flexible, so that resource consumption
need not correspond to memory deallocation.  This flexibility is
achieved through a \emph{resource typing framework}, in which
different resource management schemes can be defined by a set of
primitive types, along with operations on those types.  The definition
of a term-level primitive consists of its type, an optional pure
functional term which models the primitive, and (imperative) C code
which the Guru compiler will use for the definition of the primitive.
The connection between this C code and the pure functional model (if
supplied) must be trusted.  But since the number of lines of C code
required to implement, say, mutable arrays is very small (on the order
of tens of lines), we contend that this is a reasonable compromise
between trustedness and the burden of verification.

This paper is organized as follows.  We begin with an overview of
resource typing in \textsc{Guru}, focusing on several example resource
types.  We then consider a system of resource-typing rules, and its
soundness with respect to a resource-manipulating operational
semantics.  Finally we consider several example imperative
abstractions built on top of this resource-typing framework.

\section{Overview of \textsc{Guru}'s Resource Typing}

In this section, we define a resource-typing framework, orthogonal to
\textsc{Guru}'s datatype typing, upon which we can build various
imperative abstractions.  The starting point for this framework is the
familiar idea of modeling resources using linear types.  A resource is
considered to be an entity to which exactly one other entity refers,
while it exists in the program.  So a resource in this sense is
intended to be like a physical resource, such as a bicycle: at most
one person can make use of the bicycle at a time.  This is the first
principle of our resource-typing framework: we must have exactly one
reference to each extant resource at any point during evaluation.  To
this we add a second principle, inspired by examples of physical
resource, like the bicycle example.  For after all, more than one
person can use the bicycle, if one rides on the handle bars and
another on the seat.  Resources often consist of sub-resources (like
the handle bars and seat of the bicycle), which may be used
independently.  But while they are in use, the resource of which they
are parts is not available for use as a whole.  This is our second
principle: resources may be divided into sub-resources, but in that
case, the whole resource cannot be used by another entity until use of
the sub-resources is complete.  For another everyday example, consider
a boxed set of Harry Potter books.  The boxed set is a resource, and
the books are its sub-resources.  Different people can borrow the
individual books, but no one can borrow the entire boxed set until all
the books have been returned to it.

Our resource-typing framework allows us to track the sub-resource
relationship statically.  It also enforces the linearity discipline.
The framework allows different resource types to be declared, together
with primitive operations on them.  Primitives are declared with an
optional functional model, and then C code providing its (imperative)
implementation.  When such a primitive is declared, its resource type
is declared axiomatically: we do not check that the functional model
satisfies that resource type, but just take it as a given that the C
code's behavior matches that specified by the resource type.

\subsection{Quick introduction to \textsc{Guru}}

In order to move quickly to concrete examples, we survey first the
syntax and informal semantics of terms and types in \textsc{Guru},
including resource-type annotations.  We omit the syntax for proofs
$P$ and formulas $F$, which are separate syntactic categories in
\textsc{Guru}.  The syntax is given in Figure~\ref{fig:terms}, where
we write $o?$ to mean an optional occurrence of $o$.

\begin{figure}
\[
\begin{array}{lll}
t & ::= x\ ||\\
\ & \ &   c\ ||\\ 
\ & \ &    \texttt{fun}\ x(i_1?\ o_1?\ x_1\,:\,A_1)\cdots(i_n?\ o_n?\ x_n\,:\, A_n)\\
\ & \ & \ \ \ \ \ \ \  : o?\ T .\ t\ ||\\
\ & \ &    (t\ X)\ || \\ 
\ & \ &         \texttt{cast}\ t\ \texttt{by}\ P  \ ||\\
\ & \ &  \texttt{abort}\ T\ ||\\ 
\ & \ &  \texttt{let}\ x\ \Eq\ t\ \texttt{by}\ y\ \texttt{in}\ t' \ ||\ 
\\ 
\ & \ &  \texttt{match}\, !?\ t\ \texttt{by}\ x\ y \ \texttt{with}\\
\ & \ &  \ \ \ c_1\ \bar{x}_1\ \texttt{=>}\ t_1 |
 \cdots | c_n\ \bar{x}_n\ \texttt{=>}\ t_n\ \texttt{end}\ ||\\
\ & \ &  \texttt{existse\_term}\ P\ t\ || \\
\ & \ &  @\ t \\
\\
\\
X & ::= & t\ ||\ T\ ||\ P
\\
\\
A & ::= & T\ ||\ \texttt{type}\ ||\ F 
\\
\\
T & ::= & x\ ||\ d\ ||\ \bang\ ||\ 
     \texttt{Fun}(i?\ o?\ x\,:\,A) . o?\ T\ ||\ \langle T\ Y\rangle 
\\
\\
Y & ::= & t\ ||\ T
\\
\\
o & ::= & \#\texttt{untracked}\ ||\ \texttt{spec}\ ||\ \#\texttt{r}\ ||\ \#\langle r\ x\rangle
\\
\\
i & ::= & \textnormal{\^{\ }}\ ||\ !\ 
\end{array}
\]
\caption{\label{fig:terms} Terms ($t$) and Types ($T$)}
\end{figure}

Terms and types are as reported in our previous work~\cite{guru09},
except for the ownership annotations $o$, with their accompanying
\emph{consumption annotations} $i$.  For terms $t$, we have general
recursive functions introduced with \texttt{fun}, which lists inputs
and their types first, then a ``:'', then the output type, then a
``.'', and then the body of the function.  We support finite failure
via \texttt{abort}.  We have explicit casts to change the type of a
term $t$ using an equation between types proved by a proof $P$.  We
also have \texttt{let}- and \texttt{match}-terms.  Right after the
\texttt{match} keyword, we may optionally have $!$, which means that
the scrutinee will not be consumed by the match.  The default is that
the scrutinee will be consumed.  These \texttt{let}- and
\texttt{match}-terms bind additional assumption variables after the
\texttt{by} keyword, which provide information in the rest of those
terms about the computation that must have led there.  For example, in
\texttt{let}-terms, the assumption variable has classifier $\{ x = t
\}$, following the \texttt{let}-definition of $x$ to $t$.  This is
useful informationa in the body of the \texttt{let}, since it tells us
that $t$ has terminated, and that $x$ is provably equal to its value.
The \texttt{existse\_term} is a rarely used construct for elimination
of a proved existential formula, inside a term.  The final term
construct $@\ t$ is for compressing chains of ownership, discussed
further below.

A few words are warranted on the Operational Type Theory (OpTT) upon
which \textsc{Guru} is based.  Provable equality between terms in
\textsc{Guru} has the meaning that the two terms either both diverge
using \textsc{Guru}'s call-by-value operational semantics, or join at
a common value.  Provable equality between types has the meaning that
the types are equal modulo provable equality of any terms they contain
(as indices to indexed datatypes).  OpTT preserves decidability of
typing and logical consistency in the presence of general recursion.
Definitional (automatic) equality is very weak, and does not include
computation.  Casts are used to change the type of a term, thus
placing evaluation under the control of the programmer, instead of the
type checker.  The axiom $\texttt{join}_n\ t_1\ t_2$ states that $t_1$
and $t_2$ are joinable in at most $n$ steps (in practice, $n$ is
omitted and enforced by a global timeout).  To ensure logical
consistency, proofs are syntactically separated from terms, and a
straightforward termination analysis is used to ensure that induction
proofs are well-founded.  The separation of logical and computational
parts in a type-theoretic language has been independently proposed in
Luo's Logic-Enriched Type Theory~\cite{luo08}).

\subsection{Ownership annotations}

Let us now consider the ownership annotations $o$ and consumption
annotations $i$ (of Figure~\ref{fig:terms}).  Every term in
\textsc{Guru} has a resource type, as well as a datatype.  The
ownership annotations $o$ are given for function inputs and outputs,
in order to state that resource type, as well as to express
subresource relationships.  The different kinds of resource types
are:
\begin{itemize}
\item \textbf{\#\texttt{untracked}}.  This is for data that are not
  being treated as resources, such as scalar data (booleans, machine
  words, etc.).  Note that we do not perform closure conversion in
  \textsc{Guru}, so that we may also treat functions as untracked data
  (closure conversion would require tracking the memory for the
  closure).

\item \textbf{\texttt{spec}}. This is for specificational data, that
  are dropped during compilation and by \textsc{Guru}'s definitional
  equality.  Note that the current design does not allow declaring an
  additional resource type (other than \texttt{spec}) for
  specificational data.

\item \textbf{\#\texttt{r}}. This is for data of a declared resource
  type \texttt{r}.  We envision library designers crafting a small
  number of resource types (as we have done so far), that can then be
  used by \textsc{Guru} programmers.
 
\item \textbf{\#\texttt{<r\ x>}}. This is for data of a declared
  resource type \texttt{r}, which are subresources of $x$, where $x$
  is a variable.  If we have $\texttt{y} : \#\texttt{<r\ x>}$, then we say that
  $y$ is pinning $x$.  Our static analysis, defined below, will
  require that all pinning resources of $x$ are consumed before $x$
  itself is consumed.

\end{itemize}

\noindent If an ownership annotation is omitted, \textsc{Guru} chooses
a default of either \#\texttt{untracked}, if the datatype is flat
(like \texttt{bool}), a function type, or declared untracked by the
user; or else \#\texttt{unowned}, discussed below.

Consumption annotations $i$ refine somewhat the basic
resource-tracking of linear types.  Without any consumption
annotation, the meaning is that the input must be consumed exactly
once by the function.  An input can be consumed by passing it to
another function whose type asserts that it will consume the input
(including resource-managing primitive functions which actually
deallocate memory).  This includes passing the input to a term
constructor.  It can also be consumed by returning it from the
function.  The additional annotations $i$ mean:

\begin{itemize}

\item \textbf{\^{\ }}: consume but do not return.  This annotation
  means that the input is to be consumed by the function, but not
  returned, neither directly, nor in another data structure.

\item \textbf{!}: do not consume.  This annotation means that the
  input will not be consumed at all by the function.  This is
  primarily used when defining primitive operations for resource
  types.

\end{itemize}

\section{Example Resource Types}

In this section, we consider examples of resource types and their
associated primitive operations.  We use these resource types to
help build higher-level imperative abstractions, described later
in the paper.

\subsection{Reference-Counted Data}

The most commonly used resource type in \textsc{Guru} is
\#\texttt{unowned}.  This is the resource type for reference-counted
data, which are not pinned by some other reference.
Figure~\ref{fig:unowned} gives a listing from the \texttt{unowned.g}
library file (see \texttt{guru-lang/lib} on the 1.0 branch in the
Google Code repository, via \texttt{www.guru-lang.org}), which
declares this resource type.  This listing has four commands: a
\texttt{ResourceType}-command to declare the \texttt{unowned} resource
type; an \texttt{Init}-command to declare how subdata are to be
initialized when extracting them during pattern-matching; and two
\texttt{Define}-commands, defining primitive functions for
incrementing and decrementing the reference count.  Let us look at
these in turn:

\begin{itemize}
\item the \texttt{ResourceType}-command.  This declares the resource
  type, together with a primitive function \texttt{consume\_unowned}.
  This function will be used by the \textsc{Guru} for consuming
  elements of that resource type, in one special situation:
  \texttt{match}-terms.  By default, when we match on a piece of data,
  that data will be consumed.  The \textsc{Guru} compiler will insert
  a call to this \texttt{consume}-function after extracting the
  subdata.

  The functional model given for \texttt{consume\_unowned} is a
  trivial \textsc{Guru} function.  The C code for
  \texttt{consume\_unowned}, which follows ``\texttt{<<END}'', uses
  functions \texttt{dec}, \texttt{op}, and \texttt{releaes}, provided
  by the \textsc{Guru} runtime, to check the reference count, which
  are stored in all but the low 8 bits of a single word per
  constructor application.  If the reference count is 0 (so all those
  bits at and above bit 8 are off), then the data is released.

\item the \texttt{Init}-command.  This specifies how to initialize
  subdata $y$ of $x$ when we pattern-match on $x$.  The \textsc{Guru}
  compiler will insert a call to the given C function, whenever the
  resource type of the scrutinee of a \texttt{match} is the same as
  the first resource type listed (for $x$) in the
  \texttt{Init}-command, and the resource type of the subdatum is the
  same as the second resource type listed (for $y$).  Here, we
  initialize reference-counted subdata by incrementing their reference
  counts.  Consuming a piece of data will consume its subdata, so if
  the reference count of the scrutinee falls to $0$, we will decrement
  the reference counts of its subdata when it is consumed.  That is
  why we increment the subdata's reference counts with this
  \texttt{Init}-function, so that we still have a reference to them
  even after the scrutinee is consumed.
  
\item The \texttt{Define}-commands.  The keyword \texttt{primitive}
signals that these are primitives.  Here, it is the resource types declared for
the primitives that are of most interest.  For \texttt{inc}, the resource type
is
\[
\texttt{Fun(spec A:type)(! \#unowned y:A).\#unowned A}
\]
\noindent This says that \texttt{inc} takes a \texttt{type} $A$, and
then an element $y$ of that type.  The resource type of $y$ is
\#\texttt{unowned}, and the consumption annotation is $!$, indicating
that this $y$ will not be consumed by \texttt{inc}.  Then \texttt{inc}
will produce a new \#\texttt{unowned} $A$ as output.  So the type is
telling us (and the resource-tracking analysis) that when we increment
a reference count of some object $x$, we do not consume the reference
to $x$, but gain an additional new reference to it from \texttt{inc}.
So where there was one reference to $x$ before, there are now two
references.  So we are thinking of each reference to $x$ as a separate
resource to be tracked.

The type for \texttt{dec} just says that it consumes the given
reference.  The consumption annotation \^{\ } says that it does not
return that reference -- but this is not important in this case.

\end{itemize}

The attentive reader might be wondering about why we use \texttt{spec}
with the type $A$ given to \texttt{inc}, but not with the type $A$
given to \texttt{dec}.  The reason is that at runtime, compiled
\textsc{Guru} programs pass integers corresponding to type families
(that is, one integer for all different instances of the type family
for homogeneous lists).  This is for the benefit of the runtime
function \texttt{release}, which actually manages memory for data
constructed with the different term constructors.  So even though all
type annotations are dropped during formal reasoning in
\textsc{Guru}'s logic, some are preserved during compilation.  Here,
it turns out that \texttt{inc} does not need the type at runtime,
while \texttt{dec} (which ends up calling \texttt{release}) does.
Note that the C code for the one case has $A$ as an argument, while
in the other it does not. 

\begin{figure*}
\small
\begin{verbatim}
ResourceType unowned with
  Define primitive consume_unowned : Fun(A:type)(^ #unowned r:A).void 
  := fun(A:type)(r:A).voidi
<<END
  inline void gconsume_unowned(int A, void *r) {
    if (r == 0) return;
    dec(r);
    // fprintf(stdout,"gdec(%x) = %d\n", r, op(r) >> 8);
    if (op(r) < 256)
      release(A,r,1);
  }
END.

Init ginit_unowned_unowned(#unowned x)(#unowned y).#unowned 
<<END
  inline void *ginit_unowned_unowned(int A,void *x,void *y) {
    ginc(y);
    return y;
  }
END.

Define primitive inc : Fun(spec A:type)(! #unowned y:A).#unowned A := fun(A:type)(y:A).y 
<<END
  inline void *ginc(void *y) {
    inc(y);
    // fprintf(stdout,"ginc(%x) = %d\n", y, op(y) >> 8);
    return y;
  }
END.

Define primitive dec : Fun(A:type)(^#unowned y:A).void := fun(A:type)(y:A).voidi 
<<END
  #define gdec(A,y) gconsume_unowned(A,y)
END.
\end{verbatim}
\caption{The \texttt{unowned} resource type}
\label{fig:unowned}
\end{figure*}

\subsection{Owned Data}

One criticism of reference counting as a memory management technique
is that memory traffic generated by incrementing and decrementing
reference counts is costly in terms of performance.  We mitigate this
cost by defining a second resource type, for references which may be
created and consumed without increments and decrements of the
reference count.  The idea is that if such a reference $r$ is
(ultimately) pinning a reference-counted reference $x$ (that is, an
\texttt{unowned} reference), then it is safe to compute with $r$,
without fear that the referenced data object's memory will be
reclaimed.  The reference-counted reference $x$ cannot be consumed
until $r$ is, since $r$ is pinning $x$.  So we can use $r$ safely
without incrementing the reference count.

We list some representative primitives for this resource type in
Figure~\ref{fig:owned} (for the rest, see
\texttt{guru-lang/lib/owned.g}), and explain them as follows:

\begin{itemize}
\item \textbf{\texttt{consume\_owned}}.  As explained, we do not need to 
decrement the reference count for $x$ when we consume it.

\item \textbf{\texttt{inspect}}. This takes a reference-counted
  (\texttt{unowned}) reference $x$, and returns an \texttt{owned}
  reference pinning $x$.  This is how we obtain an \texttt{owned}
  reference.

\item \textbf{\texttt{clone\_owned}}. This takes an \texttt{owned}
  reference $y$ and creates a new \texttt{owned} reference pinning
  $y$.  Chains of ownership, where $x$ pins $y$ and $y$ pins $z$, can
  be built up in this way.  Occasionally it is necessary to collapse
  such chains, in which case we use the $@\ t$ term-construct
  (Figure~\ref{fig:terms}).  If $x$ pins $y$ and $y$ pins $z$, then
  $@\ x$ pins $z$ directly.

\item \texttt{ginit\_owned\_unowned}. This initializes an
  \texttt{unowned} subdatum $y$ of an \texttt{owned} scrutinee $x$.
  In this case, the initialized $y$ pins $x$.  This initialization has
  the effect of propagating the \texttt{owned} resource type during
  pattern-matching, and is another point at which chains of ownership
  can develop.

\end{itemize}

\begin{figure*}
\small
\begin{verbatim}
ResourceType owned with 
  Define primitive consume_owned : Fun(A:type)(^#owned x:A).void
  := fun(A:type)(x:A).voidi <<END
  inline void gconsume_owned(int A, void *x) { }
END.

Define primitive inspect : Fun(spec A:type)(!#unowned x:A).#<owned x> A 
  := fun(A:type)(x:A).x <<END
  #define ginspect(x) x
END.

Define primitive clone_owned : Fun(spec A:type)(! #owned y:A).#<owned y> A
  := fun(A:type)(y:A).y <<END
  #define gclone_owned(y) y
END.

Init ginit_owned_unowned(#owned x)(#unowned y).#<owned x> <<END
  #define ginit_owned_unowned(A,x,y) y
END.
\end{verbatim}
\caption{The \texttt{owned} resource type (selected primitives)}
\label{fig:owned}
\end{figure*}

\subsection{Unique Data}

A simple resource type is that for an object to which exactly one
reference is allowed while the object exists, without the possibility
of multiple references as above (although we will relax that slightly
below).  The resource type for this is \texttt{unique}, defined in
Figure~\ref{fig:unique}.  The interesting point to note here is that
when pattern-matching on a \texttt{unique} object, we are insisting
(with the \texttt{must\_consume\_scrutinee} directive) that the
scrutinee is indeed consumed.  We do not provide any way of
initializing \texttt{unique} subdata from a scrutinee which is not
itself \texttt{unique}.  This ensures that \texttt{unique} must
propagate from subdata to containing data.  If a term constructor's
type does not declare that it creates \texttt{unique} data, while
stating that it accepts \texttt{unique} arguments, then that
constructor could be applied, but never pattern-matched against (due
to the deliberate omission of the appropriate \texttt{Init}-function).

\begin{figure*}
\small
\begin{verbatim}
ResourceType unique with
  Define primitive consume_unique : Fun(A:type)(^#unique x:A).void
    := fun(A:type)(x:A).voidi <<END
  inline void gconsume_unique(int A, void *x) {
    release(A,x,0);
  }
END.

Init must_consume_scrutinee ginit_unique_unique(#unique x)(#unique y).#unique <<END
  #define ginit_unique_unique(A,x,y) y
END.

Init must_consume_scrutinee ginit_unique_owned(#unique x)(#owned y).#owned <<END
  #define ginit_unique_owned(A,x,y) y
END.

Init must_consume_scrutinee ginit_unique_unowned(#unique x)(#unowned y).#unowned <<END
  #define ginit_unique_unowned( A, x, y) y
END.
\end{verbatim}
\caption{The \texttt{unique} resource type}
\label{fig:unique}
\end{figure*}

\subsection{Unique-owned resource type}

We introduce a final resource type \texttt{unique\_owned}, which we
use to implement readers/writers locking.  We can obtain multiple
\texttt{unique\_owned} references $r$ from a \texttt{unique} reference
$x$, but those references pin $x$.  Our higher-level imperative
abstractions just insist that operations which update the object $o$
to which $x$ refers consume $x$, producing as output a new reference
to the (imperatively) updated $o$.  Since they consume the
\texttt{unique} $x$, our resource-tracking discipline forbids there
from being any pinning references to $x$ extant.  This ensures
(statically) that all read-only references to $o$ are consumed, before
the read-write reference $x$ can be used.

\begin{figure*}
\small
\begin{verbatim}
ResourceType unique_owned with
  Define primitive consume_unique_owned : Fun(A:type)(^#unique_owned x:A).void
  := fun(A:type)(x:A).voidi <<END
inline void gconsume_unique_owned(int A, int x) { }
END.

Init ginit_unique_owned_unique(#unique_owned x)(#unique y).#<unique_owned x> <<END
  #define ginit_unique_owned_unique(A,x,y) y
END.

Init ginit_unique_owned_owned(#unique_owned x)(#owned y).#owned <<END
  #define ginit_unique_owned_owned(A,x,y) y
END.

Init ginit_unique_owned_unowned(#unique_owned x)(#unowned y).#<owned x> <<END
  #define ginit_unique_owned_unowned(A,x,y) y
END.

Define primitive inspect_unique : Fun(spec A:type)(!#unique a:A).#<unique_owned a> A :=
  fun(spec A:type)(a:A).a <<END
#define ginspect_unique(a) a
END.

Define primitive clone_unique_owned : Fun(spec A:type)(!#unique_owned a:A).#<unique_owned a> A :=
  fun(A:type)(a:A).a <<END
#define gclone_unique_owned(a) a
END.
\end{verbatim}
\caption{The \texttt{unique\_owned} resource type (selected primitives)}
\label{fig:uniqueowned}
\end{figure*}


\section{Type System}

\section{Mutable Arrays}

\section{FIFO Queues}

\section{Empirical Results}

\section{Conclusion}

\textbf{Acknowledgements:} the U.S. NSF for support under award CCF-0841554.

\bibliographystyle{plainnat}

%\nocite{SH80}
\bibliography{partiality,misc_logic,automated_reasoning,formal_methods,verification,lf,general,refinement,coop_dec_procs,cl,rewriting,theorem_provers,sat,program_analysis,software_engineering,specification,pl,stanford_group,hoas,semantic_programming,misc}


\end{document}
